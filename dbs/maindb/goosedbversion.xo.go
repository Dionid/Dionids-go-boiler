package maindb

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/Dionid/go-boiler/pkg/dioq"
)

type GooseDbVersionTableSt struct {
	dioq.Table
	ID        dioq.Column[int]
	VersionID dioq.Column[int64]
	IsApplied dioq.Column[bool]
	Tstamp    dioq.Column[sql.NullTime]
}

func (t GooseDbVersionTableSt) As(alias string) GooseDbVersionTableSt {
	t.Table.TableAlias = fmt.Sprintf(`"%s"`, alias)
	t.ID = dioq.NewColumnWithAlias[int](t.Table, t.ID.ColumnName, t.ID.ColumnAlias)
	t.VersionID = dioq.NewColumnWithAlias[int64](t.Table, t.VersionID.ColumnName, t.VersionID.ColumnAlias)
	t.IsApplied = dioq.NewColumnWithAlias[bool](t.Table, t.IsApplied.ColumnName, t.IsApplied.ColumnAlias)
	t.Tstamp = dioq.NewColumnWithAlias[sql.NullTime](t.Table, t.Tstamp.ColumnName, t.Tstamp.ColumnAlias)

	return t
}

var GooseDbVersionTableBase = dioq.Table{
	TableName:  `"goose_db_version"`,
	TableAlias: `"goose_db_version"`,
}

var GooseDbVersionTable = GooseDbVersionTableSt{
	Table:     GooseDbVersionTableBase,
	ID:        dioq.NewColumn[int](GooseDbVersionTableBase, `"id"`),
	VersionID: dioq.NewColumn[int64](GooseDbVersionTableBase, `"version_id"`),
	IsApplied: dioq.NewColumn[bool](GooseDbVersionTableBase, `"is_applied"`),
	Tstamp:    dioq.NewColumn[sql.NullTime](GooseDbVersionTableBase, `"tstamp"`),
}

// # Constants

type (
	GooseDbVersionIDCT        = int
	GooseDbVersionVersionIDCT = int64
	GooseDbVersionIsAppliedCT = bool
	GooseDbVersionTstampCT    = sql.NullTime
)

const (
	GooseDbVersionIDCN        = `"id"`
	GooseDbVersionVersionIDCN = `"version_id"`
	GooseDbVersionIsAppliedCN = `"is_applied"`
	GooseDbVersionTstampCN    = `"tstamp"`
)

// # Model

type GooseDbVersionModel struct {
	ID        int          `json:"id" db:"id"`
	VersionID int64        `json:"version_id" db:"version_id"`
	IsApplied bool         `json:"is_applied" db:"is_applied"`
	Tstamp    sql.NullTime `json:"tstamp" db:"tstamp"`
}

func NewGooseDbVersionModel(
	ID int,
	VersionID int64,
	IsApplied bool,
	Tstamp sql.NullTime,
) *GooseDbVersionModel {
	return &GooseDbVersionModel{
		ID:        ID,
		VersionID: VersionID,
		IsApplied: IsApplied,
		Tstamp:    Tstamp,
	}
}

// ## Insertable

type InsertableGooseDbVersionModel struct {
	VersionID int64        `json:"version_id" db:"version_id"`
	IsApplied bool         `json:"is_applied" db:"is_applied"`
	Tstamp    sql.NullTime `json:"tstamp" db:"tstamp"`
}

func NewInsertableGooseDbVersionModel(
	VersionID int64,
	IsApplied bool,
	Tstamp sql.NullTime,
) *InsertableGooseDbVersionModel {
	return &InsertableGooseDbVersionModel{
		VersionID: VersionID,
		IsApplied: IsApplied,
		Tstamp:    Tstamp,
	}
}

func InsertIntoGooseDbVersionTable(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (sql.Result, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableGooseDbVersionModel is nil")
	}

	valueSetList := make([]dioq.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = dioq.ValueSet(
			dioq.VALUE(GooseDbVersionTable.VersionID, model.VersionID),
			dioq.VALUE(GooseDbVersionTable.IsApplied, model.IsApplied),
			dioq.VALUE(GooseDbVersionTable.Tstamp, model.Tstamp),
		)
	}

	query, err := dioq.Query(
		dioq.INSERT_INTO(
			GooseDbVersionTable,
			GooseDbVersionTable.VersionID,
			GooseDbVersionTable.IsApplied,
			GooseDbVersionTable.Tstamp,
		),
		dioq.VALUES(
			valueSetList...,
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoGooseDbVersionTableReturningAll(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (*GooseDbVersionModel, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableGooseDbVersionModel is nil")
	}

	valueSetList := make([]dioq.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = dioq.ValueSet(
			dioq.VALUE(GooseDbVersionTable.VersionID, model.VersionID),
			dioq.VALUE(GooseDbVersionTable.IsApplied, model.IsApplied),
			dioq.VALUE(GooseDbVersionTable.Tstamp, model.Tstamp),
		)
	}

	query, err := dioq.Query(
		dioq.INSERT_INTO(
			GooseDbVersionTable,
			GooseDbVersionTable.VersionID,
			GooseDbVersionTable.IsApplied,
			GooseDbVersionTable.Tstamp,
		),
		dioq.VALUES(
			valueSetList...,
		),
		dioq.RETURNING(GooseDbVersionTable.AllColumns()),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var model GooseDbVersionModel
	err = row.Scan(
		&model.ID,
		&model.VersionID,
		&model.IsApplied,
		&model.Tstamp,
	)
	if err != nil {
		return nil, err
	}

	return &model, nil
}

// ## Updatable

type UpdatableGooseDbVersionModel struct {
	ID        *int          `json:"id" db:"id"`
	VersionID *int64        `json:"version_id" db:"version_id"`
	IsApplied *bool         `json:"is_applied" db:"is_applied"`
	Tstamp    *sql.NullTime `json:"tstamp" db:"tstamp"`
}

func NewUpdatableGooseDbVersionModel(
	ID *int,
	VersionID *int64,
	IsApplied *bool,
	Tstamp *sql.NullTime,
) *UpdatableGooseDbVersionModel {
	return &UpdatableGooseDbVersionModel{
		ID,
		VersionID,
		IsApplied,
		Tstamp,
	}
}

// ## Select by ID
func SelectGooseDbVersionTableByID(
	ctx context.Context,
	db DB,
	ID int,
) (*GooseDbVersionModel, error) {
	query, err := dioq.Query(
		dioq.SELECT(
			GooseDbVersionTable.AllColumns(),
		),
		dioq.FROM(GooseDbVersionTable),
		dioq.WHERE(
			dioq.EQUAL(GooseDbVersionTable.ID, ID),
		),
		dioq.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &GooseDbVersionModel{}
	err = row.Scan(
		&model.ID,
		&model.VersionID,
		&model.IsApplied,
		&model.Tstamp,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by ID
func DeleteFromGooseDbVersionTableByID(
	ctx context.Context,
	db DB,
	ID int,
) (sql.Result, error) {
	query, err := dioq.Query(
		dioq.DELETE_FROM(
			GooseDbVersionTable,
		),
		dioq.WHERE(
			dioq.EQUAL(GooseDbVersionTable.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoGooseDbVersionTableReturningID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (*int, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoGooseDbVersionTableReturningIDResult is nil")
	}

	valueSetList := make([]dioq.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = dioq.ValueSet(
			dioq.VALUE(GooseDbVersionTable.VersionID, model.VersionID),
			dioq.VALUE(GooseDbVersionTable.IsApplied, model.IsApplied),
			dioq.VALUE(GooseDbVersionTable.Tstamp, model.Tstamp),
		)
	}

	query, err := dioq.Query(
		dioq.INSERT_INTO(
			GooseDbVersionTable,
			GooseDbVersionTable.VersionID,
			GooseDbVersionTable.IsApplied,
			GooseDbVersionTable.Tstamp,
		),
		dioq.VALUES(
			valueSetList...,
		),
		dioq.RETURNING(
			GooseDbVersionTable.ID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning int
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by ID
func UpdateGooseDbVersionTableByID(
	ctx context.Context,
	db DB,
	updatableModel *UpdatableGooseDbVersionModel,
	ID int,
) (sql.Result, error) {
	valuesSetList := []dioq.Statement{}

	if updatableModel.ID != nil {
		valuesSetList = append(valuesSetList, dioq.SET_VALUE(GooseDbVersionTable.ID, *updatableModel.ID))
	}
	if updatableModel.VersionID != nil {
		valuesSetList = append(valuesSetList, dioq.SET_VALUE(GooseDbVersionTable.VersionID, *updatableModel.VersionID))
	}
	if updatableModel.IsApplied != nil {
		valuesSetList = append(valuesSetList, dioq.SET_VALUE(GooseDbVersionTable.IsApplied, *updatableModel.IsApplied))
	}
	if updatableModel.Tstamp != nil {
		valuesSetList = append(valuesSetList, dioq.SET_VALUE(GooseDbVersionTable.Tstamp, *updatableModel.Tstamp))
	}

	query, err := dioq.Query(
		dioq.UPDATE(
			GooseDbVersionTable,
		),
		dioq.SET(
			valuesSetList...,
		),
		dioq.WHERE(
			dioq.EQUAL(GooseDbVersionTable.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}
